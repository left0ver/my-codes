<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>对象原型_proto_</title>
	</head>
	<body>
		<script>
			function Star(uname, age) {
				this.name = uname;
				this.age = age;
				// this.sing = function () {
				// 	console.log("我会唱歌");
				// };
			}

			Star.prototype.sing = function () {
				console.log("我会唱歌");
			};
			var ldh = new Star("刘德华", 18);
			var zxy = new Star("张学友", 19);
			ldh.sing();
			zxy.sing();
			/*
                __prototype__ 对象原型，前面有两根下划线，后面也有两根下划线
                
                创造的实例对象身上会自己添加一个__proto__来指向我们构造函数的原型对象
                 实例对象的 __proto__和构造函数里的prototype 是等价的，如下
	            console.log(ldh.__proto__ === Star.prototype); 

                方法的查找规则：先查找ldh对象身上有没有sing方法，如果有就执行这个对象上的sing方法
                没有的话，因为有__proto__的存在，就去构造函数原型对象prototype身上找是否有sing方法
             
                之所以我们的实例对象可以使用构造函数prototype原型对象里的方法，就是因为实例化的对象有__proto__（对象原型）的存在
              我们把__proto__称为对象原型，prototype称为原型对象
            */
			console.log(ldh.__proto__ === Star.prototype);
			console.log(ldh);
		</script>
	</body>
</html>
